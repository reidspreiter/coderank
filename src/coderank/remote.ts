import { promises as fs } from "fs";
import * as path from "path";

import { v4 as uuidv4 } from "uuid";
import * as v from "vscode";

import * as s from "../schemas";
import { Git, GitLoginOptions } from "../services";
import { CODERANK_FILENAME } from "../util";
import { copyDirectory } from "../util";

import { LocalStorage } from "./local";

const WEB_RECORD_FILENAME = "web-viewer-record.json";

export type RemoteFileCallback = (
    remoteFile: s.CoderankFile
) => s.CoderankFile | null | Promise<s.CoderankFile | null>;

function getREADMEContent(): string {
    return `
The contents of this directory are automatically generated by the coderank extension: https://github.com/reidspreiter/coderank.git

Please do not modify the following files in this directory, as it may affect the functionality of the coderank extension:
- README.md
- ${CODERANK_FILENAME}
- ${WEB_RECORD_FILENAME}

While it is not recommended, additional files may be added to this directory if needed. Only the files listed above will be modified by the extension, and all others will be preserved.
    `;
}

async function copyWebViewerFiles(webFilesDir: string, repoDir: string): Promise<boolean> {
    try {
        await fs.copyFile(path.join(webFilesDir, "index.html"), path.join(repoDir, "index.html"));
        await copyDirectory(path.join(webFilesDir, "static"), path.join(repoDir, "static"));
    } catch (err) {
        v.window.showErrorMessage(`Error updating web viewer: ${err}`);
        return true;
    }
    return false;
}

export class RemoteStorage {
    private constructor(
        private baseRepositoryDir: string,
        private repoCoderankDir: string,
        private coderankFilePath: string,
        private webRecordPath: string,
        private webFilesDir: string,
        private data?: s.CoderankFile
    ) {}

    static async cloneContext(
        context: v.ExtensionContext,
        callback: (remote: RemoteStorage) => boolean | Promise<boolean>,
        options: Partial<GitLoginOptions> = {}
    ): Promise<boolean> {
        const abort = await Git.loginCloneContext(
            context,
            async (repoDir) => {
                const coderankDir = path.join(repoDir, "coderank");
                const coderankFilePath = path.join(coderankDir, CODERANK_FILENAME);
                const webRecordPath = path.join(coderankDir, WEB_RECORD_FILENAME);
                const extensionWebFilesPath = path.join(
                    context.extensionUri.fsPath,
                    "out",
                    "web",
                    "src"
                );
                const remote = new RemoteStorage(
                    repoDir,
                    coderankDir,
                    coderankFilePath,
                    webRecordPath,
                    extensionWebFilesPath
                );
                await remote.initRemoteCoderankDirectory();

                let abort = callback(remote);
                if (abort instanceof Promise) {
                    abort = await abort;
                }
                if (!abort) {
                    remote.write();
                }
                return abort;
            },
            options
        );
        return abort;
    }

    async read(): Promise<s.CoderankFile> {
        if (this.data === undefined) {
            this.data =
                (await s.readJSONFile(this.coderankFilePath, s.CoderankFileSchema)) ||
                s.CoderankFileSchema.parse({});
        }
        return this.data;
    }

    async write() {
        const data = await this.read();
        await fs.writeFile(this.coderankFilePath, s.stringify(data), "utf-8");
    }

    private async initRemoteCoderankDirectory() {
        await fs.mkdir(this.repoCoderankDir, { recursive: true });
        await fs.writeFile(path.join(this.repoCoderankDir, "README.md"), getREADMEContent());
    }

    async shouldUpdateWebRecord(webViewerOptions: {
        showMessage: boolean;
        force: boolean;
    }): Promise<boolean> {
        const webRecord = await s.readJSONFile(this.webRecordPath, s.WebViewerRecordSchema);
        return (
            webRecord === null ||
            webRecord.version !== s.LATEST_WEB_VIEWER_VERSION ||
            webViewerOptions.force
        );
    }

    async updateWebViewer(
        options: { showMessage: boolean; force: boolean } = { showMessage: false, force: false }
    ): Promise<boolean> {
        const webRecord =
            (await s.readJSONFile(this.webRecordPath, s.WebViewerRecordSchema)) ||
            s.WebViewerRecordSchema.parse({ version: "" });
        if (webRecord.version !== s.LATEST_WEB_VIEWER_VERSION) {
            webRecord.version = s.LATEST_WEB_VIEWER_VERSION;
            const aborted = await copyWebViewerFiles(this.webFilesDir, this.baseRepositoryDir);
            if (aborted) {
                return true;
            }
            await fs.writeFile(this.webRecordPath, s.stringify(webRecord), "utf-8");
            if (options.showMessage) {
                v.window.showInformationMessage(
                    `Updated web viewer to ${s.LATEST_WEB_VIEWER_VERSION}`
                );
            }
        } else if (options.force) {
            const aborted = await copyWebViewerFiles(this.webFilesDir, this.baseRepositoryDir);
            if (aborted) {
                return true;
            }
            if (options.showMessage) {
                v.window.showInformationMessage(
                    "Web viewer was already up to date, but replaced web files anyways"
                );
            }
        } else if (options.showMessage) {
            v.window.showInformationMessage(
                `Web viewer is already up to date: ${s.LATEST_WEB_VIEWER_VERSION}`
            );
        }
        return false;
    }

    async addLocalFile(
        localStorage: LocalStorage,
        machineRegistry: s.MachineRegistry,
        setMachineRegistry: (registry: s.MachineRegistry) => Promise<void>
    ): Promise<s.CoderankProviderStats> {
        let remoteData = await this.read();
        const localData = await localStorage.readCoderankFile();

        if (!machineRegistry.inRemote) {
            for (const year in remoteData.years) {
                if (machineRegistry.id in remoteData.years[year].machines) {
                    let newID = uuidv4();
                    while (newID === machineRegistry.id) {
                        newID = uuidv4();
                    }

                    machineRegistry.id = newID;
                    break;
                }
            }
            machineRegistry.inRemote = true;
            await setMachineRegistry(machineRegistry);
        }
        remoteData = s.sumLocalFileToRemoteFile(remoteData, localData);

        return s.getProviderStatsFromFile(remoteData, machineRegistry.id, s.EDITOR_NAME);
    }

    async updateData(callback: RemoteFileCallback): Promise<boolean> {
        let callbackResult = callback(await this.read());
        if (callbackResult instanceof Promise) {
            callbackResult = await callbackResult;
        }

        if (callbackResult === null) {
            return true;
        }
        this.data = callbackResult;
        return false;
    }
}
