import { promises as fs } from "fs";
import * as path from "path";

import { v4 as uuidv4 } from "uuid";
import * as v from "vscode";

import * as s from "../schemas";
import { Git, GitLoginOptions } from "../services";
import { CODERANK_FILENAME } from "../util";
import { copyDirectory } from "../util";

import { LocalStorage } from "./local";

const WEB_RECORD_FILENAME = "web-viewer-record.json";

export type RemoteFileCallback = (
    remoteFile: s.CoderankFile
) => s.CoderankFile | null | Promise<s.CoderankFile | null>;

function getREADMEContent(): string {
    return `
The contents of this directory are automatically generated by the coderank extension: https://github.com/reidspreiter/coderank.git

Please do not modify the following files in this directory, as it may affect the functionality of the coderank extension:
- README.md
- ${CODERANK_FILENAME}
- ${WEB_RECORD_FILENAME}

While it is not recommended, additional files may be added to this directory if needed. Only the files listed above will be modified by the extension, and all others will be preserved.
    `;
}

async function copyWebViewerFiles(coderankDir: string, repoDir: string): Promise<void> {
    const webPath = path.join(coderankDir, "out", "web", "src");
    await fs.copyFile(path.join(webPath, "index.html"), path.join(repoDir, "index.html"));
    await copyDirectory(path.join(webPath, "static"), path.join(repoDir, "static"));
}

export class RemoteStorage {
    private constructor(
        private directory: string,
        private coderankDir: string,
        private coderankFilePath: string,
        private webRecordPath: string,
        private data?: s.CoderankFile
    ) {}

    static async cloneContext(
        context: v.ExtensionContext,
        callback: (remote: RemoteStorage) => boolean | Promise<boolean>,
        options: Partial<GitLoginOptions> = {}
    ): Promise<boolean> {
        const abort = await Git.loginCloneContext(
            context,
            async (repoDir) => {
                const coderankDir = path.join(repoDir, "coderank");
                const coderankFilePath = path.join(coderankDir, CODERANK_FILENAME);
                const webRecordPath = path.join(coderankDir, WEB_RECORD_FILENAME);
                const remote = new RemoteStorage(
                    repoDir,
                    coderankDir,
                    coderankFilePath,
                    webRecordPath
                );
                await remote.initRemoteCoderankDirectory();

                let abort = callback(remote);
                if (abort instanceof Promise) {
                    abort = await abort;
                }
                if (!abort) {
                    remote.write();
                }
                return abort;
            },
            options
        );
        return abort;
    }

    async read(): Promise<s.CoderankFile> {
        if (this.data === undefined) {
            this.data =
                (await s.readJSONFile(this.coderankFilePath, s.CoderankFileSchema)) ||
                s.CoderankFileSchema.parse({});
        }
        return this.data;
    }

    async write() {
        const data = await this.read();
        await fs.writeFile(this.coderankFilePath, s.stringify(data), "utf-8");
    }

    private async initRemoteCoderankDirectory() {
        await fs.mkdir(this.coderankDir, { recursive: true });
        await fs.writeFile(path.join(this.coderankDir, "README.md"), getREADMEContent());
    }

    async shouldUpdateWebRecord(webViewerOptions: {
        showMessage: boolean;
        force: boolean;
    }): Promise<boolean> {
        const webRecord = await s.readJSONFile(this.webRecordPath, s.WebViewerRecordSchema);
        return (
            webRecord === null ||
            webRecord.version !== s.LATEST_WEB_VIEWER_VERSION ||
            webViewerOptions.force
        );
    }

    async updateWebViewer(
        options: { showMessage: boolean; force: boolean } = { showMessage: false, force: false }
    ) {
        const webRecord = await s.readJSONFile(this.webRecordPath, s.WebViewerRecordSchema);
        if (webRecord === null) {
            await fs.writeFile(
                this.webRecordPath,
                JSON.stringify(s.WebViewerRecordSchema.parse({})),
                "utf-8"
            );
            await copyWebViewerFiles(this.coderankDir, this.directory);
            if (options.showMessage) {
                v.window.showInformationMessage(
                    `Updated web viewer to ${s.LATEST_WEB_VIEWER_VERSION}`
                );
            }
        } else if (webRecord.version !== s.LATEST_WEB_VIEWER_VERSION) {
            webRecord.version = s.LATEST_WEB_VIEWER_VERSION;
            await fs.writeFile(this.webRecordPath, JSON.stringify(webRecord), "utf-8");
            await copyWebViewerFiles(this.coderankDir, this.directory);
            if (options.showMessage) {
                v.window.showInformationMessage(
                    `Updated web viewer to ${s.LATEST_WEB_VIEWER_VERSION}`
                );
            }
        } else if (options.force) {
            await copyWebViewerFiles(this.coderankDir, this.directory);
            if (options.showMessage) {
                v.window.showInformationMessage(
                    `Web viewer was already up to date, but replaced web files anyways`
                );
            }
        } else if (options.showMessage) {
            v.window.showInformationMessage(
                `Web viewer is already up to date: ${s.LATEST_WEB_VIEWER_VERSION}`
            );
        }
    }

    async addLocalFile(
        localStorage: LocalStorage,
        machineRegistry: s.MachineRegistry,
        setMachineRegistry: (registry: s.MachineRegistry) => Promise<void>
    ): Promise<s.CoderankProviderStats> {
        let remoteData = await this.read();
        const localData = await localStorage.readCoderankFile();

        if (!machineRegistry.inRemote) {
            for (const year in remoteData.years) {
                if (machineRegistry.id in remoteData.years[year].machines) {
                    let newID = uuidv4();
                    while (newID === machineRegistry.id) {
                        newID = uuidv4();
                    }

                    machineRegistry.id = newID;
                    machineRegistry.inRemote = true;
                    await setMachineRegistry(machineRegistry);
                    break;
                }
            }
        }
        remoteData = s.sumLocalFileToRemoteFile(remoteData, localData);

        return s.getProviderStatsFromFile(remoteData, machineRegistry.id, s.EDITOR_NAME);
    }

    async updateData(callback: RemoteFileCallback): Promise<boolean> {
        let callbackResult = callback(await this.read());
        if (callbackResult instanceof Promise) {
            callbackResult = await callbackResult;
        }

        if (callbackResult === null) {
            return true;
        }
        this.data = callbackResult;
        return false;
    }
}
