import { promises as fs } from "fs";
import * as path from "path";

import * as v from "vscode";

import * as s from "../schemas";
import { Git, GitLoginOptions } from "../services";
import { CODERANK_FILENAME } from "../util";
import { copyDirectory } from "../util";

const WEB_RECORD_FILENAME = "web-viewer-record.json";

function getREADMEContent(): string {
    return `
The contents of this directory are automatically generated by the coderank extension: https://github.com/reidspreiter/coderank.git

Please do not modify the following files in this directory, as it may affect the functionality of the coderank extension:
- README.md
- ${CODERANK_FILENAME}
- ${WEB_RECORD_FILENAME}

While it is not recommended, additional files may be added to this directory if needed. Only the files listed above will be modified by the extension, and all others will be preserved.
    `;
}

async function copyWebViewerFiles(coderankDir: string, repoDir: string): Promise<void> {
    const webPath = path.join(coderankDir, "out", "web", "src");
    await fs.copyFile(path.join(webPath, "index.html"), path.join(repoDir, "index.html"));
    await copyDirectory(path.join(webPath, "static"), path.join(repoDir, "static"));
}

export class RemoteStorage {
    private constructor(
        private directory: string,
        private coderankDir: string,
        private coderankFilePath: string
    ) {}

    static async cloneContext(
        context: v.ExtensionContext,
        callback: (remote: RemoteStorage) => void | Promise<void>,
        options: Partial<GitLoginOptions> = {}
    ) {
        await Git.loginCloneContext(
            context,
            async (repoDir: string) => {
                const coderankDir = path.join(repoDir, "coderank");
                const coderankFilePath = path.join(coderankDir, CODERANK_FILENAME);
                const remote = new RemoteStorage(repoDir, coderankDir, coderankFilePath);
                await remote.update();
                const callbackResult = callback(remote);
                if (callbackResult instanceof Promise) {
                    await callbackResult;
                }
            },
            options
        );
    }

    private async update() {
        await fs.mkdir(this.coderankDir, { recursive: true });
        await fs.writeFile(path.join(this.coderankDir, "README.md"), getREADMEContent());
    }

    async updateWebViewer(
        options: { showMessage: boolean; force: boolean } = { showMessage: false, force: false }
    ) {
        const webRecordPath = path.join(this.coderankDir, WEB_RECORD_FILENAME);
        const webRecord = await s.readJSONFile(webRecordPath, s.WebViewerRecordSchema);

        if (webRecord === null) {
            await fs.writeFile(
                webRecordPath,
                JSON.stringify(s.WebViewerRecordSchema.parse({})),
                "utf-8"
            );
            await copyWebViewerFiles(this.coderankDir, this.directory);
            if (options.showMessage) {
                v.window.showInformationMessage(
                    `Updated web viewer to ${s.LATEST_WEB_VIEWER_VERSION}`
                );
            }
        } else if (webRecord.version !== s.LATEST_WEB_VIEWER_VERSION) {
            webRecord.version = s.LATEST_WEB_VIEWER_VERSION;
            await fs.writeFile(webRecordPath, JSON.stringify(webRecord), "utf-8");
            await copyWebViewerFiles(this.coderankDir, this.directory);
            if (options.showMessage) {
                v.window.showInformationMessage(
                    `Updated web viewer to ${s.LATEST_WEB_VIEWER_VERSION}`
                );
            }
        } else if (options.force) {
            await copyWebViewerFiles(this.coderankDir, this.directory);
            if (options.showMessage) {
                v.window.showInformationMessage(
                    `Web viewer was already up to date, but replaced web files anyways`
                );
            }
        } else if (options.showMessage) {
            v.window.showInformationMessage(
                `Web viewer is already up to date: ${s.LATEST_WEB_VIEWER_VERSION}`
            );
        }
    }

    async readCoderankFile(): Promise<s.CoderankFile> {
        let data = await s.readJSONFile(this.coderankFilePath, s.CoderankFileSchema);
        return data || s.CoderankFileSchema.parse({});
    }

    async addLocalFile(localFile: s.CoderankFile): Promise<s.CoderankProviderStats> {
        let remoteFile = await this.readCoderankFile();
        remoteFile = s.sumLocalFileToRemoteFile(remoteFile, localFile);
        await fs.writeFile(this.coderankFilePath, s.stringify(remoteFile), "utf-8");
        return s.CoderankProviderStatsSchema.parse(remoteFile);
    }
}
